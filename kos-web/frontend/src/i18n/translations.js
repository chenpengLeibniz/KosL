/**
 * 中英文文案，key 与各页面 t('key') 对应
 */
export const translations = {
  zh: {
    appTitle: 'KOS-TL 应用展示系统',
    navOverview: '概览',
    navCore: 'Core',
    navCoreLoad: 'Core 加载',
    navCoreSubTypes: '类型环境',
    navCoreSubLoad: '加载',
    navRuntime: 'Runtime',
    navKernel: 'Kernel',
    navGraph: '知识图谱',
    navTrace: '轨迹',
    navScenarios: '场景',
    navScenariosSubOverview: '场景总览',
    navCounterfactual: '反事实推理',
    navCompliance: '合规性决策',
    navScenariosSubAudit: '审计与问责',
    navScenariosSubGovernance: '复杂系统治理',
    navScenariosSubAiGovernance: 'AI 治理',
    langZh: '中文',
    langEn: 'English',
    themeDark: '深色',
    themeLight: '浅色',

    commonLoading: '加载中…',
    commonReset: '重置',
    commonClear: '清空',
    commonPrev: '上一步',
    commonNext: '下一步',
    refresh: '刷新',
    retry: '重试',
    commonClose: '关闭',

    dashboardTitle: '系统概览',
    dashboardIntro: '参考 monograph「KOS-TL 的应用示例」：Core 加载类型与谓词，Runtime 捕获/模拟信号，Kernel 小步演化并生成轨迹。',
    dashboardRecommendedFlow: '推荐流程：Core 加载 → 导入 .kos 或粘贴 KOS → Runtime 生成信号并「生效」→ Kernel「执行一步」或「执行至队列空」→ 轨迹/场景/图谱查看。',
    dashboardLogsCount: '已保存日志',
    dashboardCore: 'Core 层',
    dashboardRuntime: 'Runtime 层',
    dashboardKernel: 'Kernel 层',
    dashboardView: '交互查看',
    typesCount: '预定义类型数',
    signalsCount: '最近信号数',
    viewTypesPredicates: '查看类型与谓词 →',
    sensorSim: '传感器信号模拟 →',
    stateEvolve: '状态与演化 →',
    knowledgeGraph: '知识图谱',
    trace: '轨迹',

    coreTitle: 'Core 层：类型与谓词',
    coreIntro: '所有内容仅通过「Core 加载」注入，并同步到 Kernel 的 Γ。',
    coreNoPreload: '不预加载。请通过',
    coreNoPreload2: '注入类型与谓词。',
    coreEmptyTypes: '当前无类型，请通过 Core 加载 添加。',
    coreEmptyPredicates: '当前无谓词，请通过 Core 加载 添加。',
    coreEmptyConstructors: '当前无构造函数。',
    typesInGamma: '类型 (Γ 中类型)',
    predicates: '谓词',
    constructors: '构造函数',

    coreLoadTitle: 'Core 加载：从 KOS 格式加载类型或谓词',
    coreLoadIntro: '在下方输入 KOS 风格的类型或谓词定义，点击「加载到 Core」后，将追加到 Core 层动态库；可在 Core 页查看当前类型与谓词。',
    coreLoadFormat: '支持格式示例：',
    coreLoadPlaceholder: '输入 KOS 格式的类型或谓词定义…',
    loadToCore: '加载到 Core',
    clearDynamic: '清空动态加载',
    viewCoreTypes: '查看 Core 类型与谓词',
    loadSuccess: '加载成功：新增类型 {types} 个，谓词 {predicates} 个，构造函数 {constructors} 个。',
    clearedDynamic: '已清空通过 KOS 动态加载的类型与谓词。',
    importKosFile: '导入 .kos 文件',
    importKosFileHint: '选择后自动解析并加载类型、谓词与构造函数',
    coreSyncKernel: '（已同步到 Kernel Γ）',

    runtimeTitle: 'Runtime 层：传感器信号模拟',
    runtimeIntro: '模拟 IoT 传感器流、质检上报、工单执行等；捕获的原始信号可由 Kernel 精化为事件对。',
    kindRandom: '随机',
    kindProcStep: '生产步骤',
    kindAnomaly: '异常',
    kindFailEvt: '失效事件',
    kindSensor: '传感器',
    kindQcFailure: '质检失效',
    batch5: '批量 5 条',
    batchN: '批量 {n} 条',
    latestSignals: '最新信号 (最近 50 条)',
    noSignals: '暂无信号，请点击上方按钮生成。',
    applySignals: '生效',
    noSignalsToApply: '暂无信号可生效，请先生成。',
    applyEnqueued: '已入队 {n} 条事件到 Kernel 队列 P。',
    applyGoToKernel: '→ 前往 Kernel 查看并执行',
    logSave: '保存日志',
    logReplay: '重放',
    logSectionTitle: '日志与重放',
    logSectionIntro: '实时录制：开启后每次「生效」的信号会写入录制缓冲；停止录制后保存为一条日志。也可将当前信号缓冲另存为日志。重放将已保存日志中的信号重新入队到 Kernel。',
    logRecordingStart: '开始录制',
    logRecordingStop: '停止并保存',
    logRecordingStatus: '录制中，已录 {n} 条',
    logSaveCurrent: '保存当前缓冲为日志',
    logNamePlaceholder: '日志名称（可选）',
    logListTitle: '已保存日志',
    logListEmpty: '暂无已保存日志。',
    logReplayThis: '重放',
    logReplayAndEvolve: '重放并演化',
    logReplayStepsDone: '重放后已执行 {n} 步。',
    logCount: '{n} 条',
    autoEvolveTitle: '自动演化',
    autoEvolveIntro: '按当前情况自动生成指定长度的信号序列，能精化为事件类型的入队并自动执行小步；支持保存为日志以便回放与合规审计。',
    autoEvolveSequenceLength: '序列长度',
    autoEvolveGenerate: '生成并演化',
    autoEvolveResult: '生成 {generated} 条，入队 {enqueued} 条，执行 {steps} 步',
    autoEvolveSaveAsLog: '保存为日志',
    autoEvolveGoToKernel: '→ Kernel',
    autoEvolveGoToScenarios: '→ 场景（审计/合规）',
    needNewTypeTitle: '可能需要新类型',
    needNewTypeHint: '请在 Core 加载 中添加对应类型后重试。',
    newTypeModalTitle: '发现新类型',
    newTypeModalMessage: '事件类型「{name}」未在 Core 中定义。是否通过 Core 创建该类型？',
    newTypeAllowCreate: '允许并创建',
    newTypeDiscard: '丢弃',
    queueHead: '队首',
    queueTail: '队尾',

    validEventTypesHint: '仅以下事件类型可入队',
    creatableTypesFromCore: '按 Core 类型生成（mk_XXX）',
    noSuggestedToApply: '暂无编辑项可生效，请先「根据轨迹生成」或「从日志加载」。',
    applyRejected: '拒绝 {n} 条',
    suggestFromHistoryTitle: '从历史生成',
    suggestFromHistoryIntro: '根据 Kernel 轨迹或已保存日志生成有效事件示例，可编辑后再生效。仅符合事件类型的实例会入队。',
    suggestFromTrace: '根据轨迹生成示例',
    loadFromLog: '从日志加载',
    applySuggested: '将下方事件生效',
    editableEventList: '可编辑事件列表',
    rejectedList: '未入队（不符合事件类型或精化失败）',
    commonRemove: '移除',

    kernelTitle: 'Kernel 层：Γ、σ 与事件队列',
    kernelIntro: 'Runtime 生效的信号进入事件队列 P；小步执行后按事件类型自动推演根因/审计等，并物化到 Runtime。',
    ingestOne: '摄入下一条信号并演化',
    kernelStepOne: '执行一步',
    kernelStepDrain: '执行至队列空',
    resetSigma: '重置 σ',
    logicClock: '逻辑时钟 TS',
    knowledgeCount: '知识项数 |K|',
    traceSteps: '轨迹步数',
    queueLength: '队列 |P|',
    gamma: '类型环境',
    gammaFromCore: '由 Core 加载 同步。',
    gammaEmpty: '暂无，请先在 Core 加载 中加载类型与谓词。',
    eventQueue: '事件队列 P',
    eventQueueHint: 'Runtime「生效」后的信号在此排队，点击「执行一步」按小步语义演化。',
    queueEmpty: '队列为空。请在 Runtime 生成信号并点击「生效」。',
    knowledgeEvolveTrajectory: '知识演进轨迹',
    autoRootCause: '自动根因追溯',
    autoAudit: '自动审计',
    materialized: '已物化',
    materializedHint: '小步演化后写入 Runtime 的实例或类型。',
    knowledgeSetK: '知识集 K (当前项)',
    noItems: '暂无项。',
    traceRecent: '轨迹 (最近几步)',
    noTrace: '暂无轨迹。',
    step: '步',
    noMoreSignals: '没有更多信号可摄入，请先在 Runtime 生成。',

    graphTitle: '知识图谱：Γ 与 σ 轨迹演化',
    graphIntro: '依赖类型论视角；拖动滑块切换状态，查看当前步可见的类型与项。',
    graphExampleNote: '当前节点与边为示例拓扑（与 quality_traceability 本体一致）；后续可支持从 Core Γ 动态生成。',
    stateStep: '状态步',
    initialState: 'Γ₀, σ₀ (初始)',
    legendAtom: '原子类型',
    legendComposite: '复合类型',
    legendPredicate: '谓词',
    legendConstructor: '构造函数',
    legendTerm: '项实例',

    traceTitle: '轨迹 (Trace)',
    traceIntro: 'T = σ₀ →^⟨e₁,p₁⟩ σ₁ → … ；小步演化序列，用于因果追溯与回放。',
    stepList: '步骤列表',
    traceEmpty: '暂无轨迹。请在 Runtime 生成信号，再在 Kernel 中「摄入下一条信号并演化」。',
    filterByEventType: '按事件类型筛选',
    filterAll: '全部',
    clearFocus: '取消聚焦',
    expand: '展开',
    collapse: '收起',
    traceFullPage: '完整轨迹页',

    scenariosTitle: '六大核心场景',
    scenariosIntro: '对应 all_scenarios_demo：根因追溯、反事实推理、合规性决策、审计问责、复杂系统治理、AI 治理。',
    scenario1Title: '1. 根因追溯',
    scenario1Desc: 'prove RootCauseReport：给定失效事件，由 proof 自动构造根因报告。',
    scenario1Run: '执行根因追溯',
    scenario2Title: '2. 反事实推理',
    scenario2Desc: '事实 ctx 可证 RootCauseReport，反事实 ctx（无 anomalyEx）不可证 → anomalyEx 因果必要。',
    scenario2Run: '执行反事实推理',
    counterfactualEnvTitle: '反事实推理应用环境',
    counterfactualEnvIntro: '对比「事实世界」（含异常 anomalyEx）与「反事实世界」（排除该异常），在两种上下文中对 RootCauseReport 做 prove；若事实可证、反事实不可证，则异常对根因因果必要。',
    counterfactualGoal: '证明目标：',
    counterfactualSignals: 'Runtime 建议信号链',
    counterfactualBuildSignals: '在 Runtime 层构建信号',
    counterfactualBuildSignalsIntro: '可在 Runtime 生成两类轨迹对应的信号，再在 Kernel 演化或直接在此执行对比。',
    counterfactualBuildFactual: '事实：生成 proc_step → anomaly → fail_evt（按时间顺序），生效后到 Kernel 执行步。',
    counterfactualBuildCounter: '反事实：仅生成 proc_step → fail_evt（不生成 anomaly），用于对比。',
    counterfactualGoRuntime: '前往 Runtime 生成信号',
    counterfactualGoScenarios: '前往场景页',
    counterfactualRunTitle: '执行对比',
    scenario3Title: '3. 合规性决策',
    scenario3Desc: 'enqueue_if_compliant：在摄入前检查信号是否合规。',
    scenario3Run: '检查合规性',
    complianceEnvTitle: '合规性决策应用环境',
    complianceEnvIntro: '在信号入队前进行合规检查：仅允许规定类型入队，不合规信号拒绝并返回原因。可在本页用 Runtime 生成的信号快速验证。',
    complianceEnvRule: '当前规则',
    complianceValidKinds: '合规类型：',
    complianceBuildSignals: '在 Runtime 层构建信号',
    complianceBuildIntro: '在 Runtime 生成 proc_step、anomaly、fail_evt（合规）或 sensor、qc_failure（不合规），再回到本页或场景页执行检查。',
    complianceRunTitle: '执行合规检查',
    complianceRunIntro: '选择一种信号类型，由系统生成一条示例信号并执行合规检查。',
    complianceCheckWith: '用',
    complianceSignalJson: '查看信号 JSON',
    scenario4Title: '4. 审计与问责',
    scenario4Desc: 'export_audit_trail：导出轨迹为审计 JSON。',
    scenario4Run: '导出审计轨迹',
    auditEnvTitle: '审计与问责应用环境',
    auditEnvIntro: '将当前 Kernel 轨迹导出为审计 JSON，用于追溯与问责。需先在 Runtime 生效信号并在 Kernel 执行步以形成轨迹。',
    auditEnvRule: '环境说明',
    auditRunTitle: '执行审计导出',
    auditTraceLength: '轨迹步数',
    scenario5Title: '5. 复杂系统治理',
    scenario5Desc: 'evolve_until_idle：演化直至空闲，摄入所有待处理信号。',
    scenario5Run: '演化直至空闲',
    governanceEnvTitle: '复杂系统治理应用环境',
    governanceEnvIntro: '从 Runtime 模拟器取信号并逐条摄入 Kernel 直至空闲，用于复杂系统治理演示。',
    governanceEnvRule: '环境说明',
    governanceRunTitle: '执行演化直至空闲',
    governanceResultTitle: '执行结果',
    governanceConsumed: '消费条数',
    scenario6Title: '6. AI 治理',
    scenario6Desc: 'verify_ai_suggestion：校验 AI 建议项是否满足给定类型。',
    scenario6Run: '校验 AI 建议',
    aiGovernanceEnvTitle: 'AI 治理应用环境',
    aiGovernanceEnvIntro: '校验给定项（term）是否满足给定类型（type），用于 AI 建议项的类型合规检查。',
    aiGovernanceEnvRule: '环境说明',
    aiGovernanceRunTitle: '执行类型校验',
    aiGovernanceResultTitle: '校验结果',

    vizRootCauseTitle: '根因追溯过程',
    vizAnomaly: '异常',
    vizTimeline: '时间线',
    vizCounterfactualTitle: '反事实推理对比',
    vizFactual: '事实世界',
    vizCounterfactual: '反事实世界',
    vizNecessary: 'anomalyEx 因果必要',
    vizNotNecessary: 'anomalyEx 非因果必要',
    vizComplianceTitle: '合规性决策流程',
    vizTypeCheck: '类型检查',
    vizCompliant: '合规',
    vizReject: '拒绝',
    vizAuditTitle: '审计轨迹',
    vizRawJson: '原始 JSON',
    downloadAuditJson: '下载审计 JSON',
    vizEvolveTitle: '演化直至空闲',
    vizSignalsQueue: '待处理信号',
    vizSteps: '步',
    vizConsumed: '已摄入',
    vizAiTitle: 'AI 建议校验',
  },
  en: {
    appTitle: 'KOS-TL Application Demo',
    navOverview: 'Overview',
    navCore: 'Core',
    navCoreLoad: 'Core Load',
    navCoreSubTypes: 'Types',
    navCoreSubLoad: 'Load',
    navRuntime: 'Runtime',
    navKernel: 'Kernel',
    navGraph: 'Knowledge Graph',
    navTrace: 'Trace',
    navScenarios: 'Scenarios',
    navScenariosSubOverview: 'Overview',
    navCounterfactual: 'Counterfactual',
    navCompliance: 'Compliance',
    navScenariosSubAudit: 'Audit & accountability',
    navScenariosSubGovernance: 'Governance',
    navScenariosSubAiGovernance: 'AI governance',
    langZh: '中文',
    langEn: 'English',
    themeDark: 'Dark',
    themeLight: 'Light',

    commonLoading: 'Loading…',
    commonReset: 'Reset',
    commonClear: 'Clear',
    commonPrev: 'Prev',
    commonNext: 'Next',
    refresh: 'Refresh',
    retry: 'Retry',
    commonClose: 'Close',

    dashboardTitle: 'Overview',
    dashboardIntro: 'From monograph "KOS-TL Application Example": Core loads types & predicates, Runtime captures/simulates signals, Kernel performs small-step evolution and produces trace.',
    dashboardRecommendedFlow: 'Recommended flow: Core Load → import .kos or paste KOS → Runtime generate & Apply → Kernel Step or Run until queue empty → view Trace / Scenarios / Graph.',
    dashboardLogsCount: 'Saved logs',
    dashboardCore: 'Core Layer',
    dashboardRuntime: 'Runtime Layer',
    dashboardKernel: 'Kernel Layer',
    dashboardView: 'View',
    typesCount: 'Predefined types',
    signalsCount: 'Recent signals',
    viewTypesPredicates: 'View types & predicates →',
    sensorSim: 'Sensor signal simulation →',
    stateEvolve: 'State & evolution →',
    knowledgeGraph: 'Knowledge graph',
    trace: 'Trace',

    coreTitle: 'Core: Types & Predicates',
    coreIntro: 'All content is injected only via Core Load and synced to Kernel Γ.',
    coreNoPreload: 'No preload. Use',
    coreNoPreload2: 'to inject types and predicates.',
    coreEmptyTypes: 'No types. Add via Core Load.',
    coreEmptyPredicates: 'No predicates. Add via Core Load.',
    coreEmptyConstructors: 'No constructors.',
    typesInGamma: 'Types (in Γ)',
    predicates: 'Predicates',
    constructors: 'Constructors',

    coreLoadTitle: 'Core Load: Load Types or Predicates from KOS',
    coreLoadIntro: 'Enter KOS-style type or predicate definitions below; click "Load to Core" to append to the Core dynamic library. View current types & predicates on the Core page.',
    coreLoadFormat: 'Format examples: ',
    coreLoadPlaceholder: 'Enter KOS type or predicate definitions…',
    loadToCore: 'Load to Core',
    clearDynamic: 'Clear dynamic load',
    viewCoreTypes: 'View Core types & predicates',
    loadSuccess: 'Loaded: {types} types, {predicates} predicates, {constructors} constructors added.',
    clearedDynamic: 'Cleared dynamically loaded types and predicates.',
    importKosFile: 'Import .kos file',
    importKosFileHint: 'Select a file to parse and load types, predicates, constructors',
    coreSyncKernel: '(synced to Kernel Γ)',

    runtimeTitle: 'Runtime: Sensor Signal Simulation',
    runtimeIntro: 'Simulates IoT sensor streams, quality reports, work orders; raw signals can be refined by Kernel into event pairs.',
    kindRandom: 'Random',
    kindProcStep: 'Proc step',
    kindAnomaly: 'Anomaly',
    kindFailEvt: 'Fail event',
    kindSensor: 'Sensor',
    kindQcFailure: 'QC failure',
    batch5: 'Batch 5',
    batchN: 'Batch {n}',
    latestSignals: 'Latest signals (last 50)',
    noSignals: 'No signals. Click above to generate.',
    applySignals: 'Apply',
    noSignalsToApply: 'No signals to apply. Generate first.',
    applyEnqueued: '{n} events enqueued to Kernel queue P.',
    applyGoToKernel: '→ Go to Kernel to run steps',
    logSave: 'Save log',
    logReplay: 'Replay',
    logSectionTitle: 'Log & Replay',
    logSectionIntro: 'Recording: while on, every "Apply" appends signals to a buffer; stop to save as a log. You can also save the current signal buffer as a log. Replay re-enqueues a saved log into the Kernel.',
    logRecordingStart: 'Start recording',
    logRecordingStop: 'Stop & save',
    logRecordingStatus: 'Recording, {n} signals',
    logSaveCurrent: 'Save current buffer as log',
    logNamePlaceholder: 'Log name (optional)',
    logListTitle: 'Saved logs',
    logListEmpty: 'No saved logs.',
    logReplayThis: 'Replay',
    logReplayAndEvolve: 'Replay & evolve',
    logReplayStepsDone: 'Replay: {n} steps executed.',
    logCount: '{n} signals',
    autoEvolveTitle: 'Auto evolve',
    autoEvolveIntro: 'Generate a signal sequence of chosen length, enqueue refinable events, and run small-step automatically; save as log for replay and compliance audit.',
    autoEvolveSequenceLength: 'Sequence length',
    autoEvolveGenerate: 'Generate & evolve',
    autoEvolveResult: 'Generated {generated}, enqueued {enqueued}, steps {steps}',
    autoEvolveSaveAsLog: 'Save as log',
    autoEvolveGoToKernel: '→ Kernel',
    autoEvolveGoToScenarios: '→ Scenarios (audit/compliance)',
    needNewTypeTitle: 'New type may be needed',
    needNewTypeHint: 'Add the type in Core Load and try again.',
    newTypeModalTitle: 'New type detected',
    newTypeModalMessage: 'Event type "{name}" is not defined in Core. Create it via Core?',
    newTypeAllowCreate: 'Create in Core',
    newTypeDiscard: 'Discard',
    queueHead: 'Head',
    queueTail: 'Tail',

    validEventTypesHint: 'Only these event types can be enqueued',
    creatableTypesFromCore: 'Generate by Core type (mk_XXX)',
    noSuggestedToApply: 'No editable items to apply. Suggest from trace or load from log first.',
    applyRejected: '{n} rejected',
    suggestFromHistoryTitle: 'Generate from history',
    suggestFromHistoryIntro: 'Generate valid event examples from Kernel trace or saved logs; edit then apply. Only instances matching event types are enqueued.',
    suggestFromTrace: 'Suggest from trace',
    loadFromLog: 'Load from log',
    applySuggested: 'Apply events below',
    editableEventList: 'Editable event list',
    rejectedList: 'Rejected (not a valid event type or elaboration failed)',
    commonRemove: 'Remove',

    kernelTitle: 'Kernel: Γ, σ & Event Queue',
    kernelIntro: 'Signals applied in Runtime enter queue P; each step runs small-step semantics and auto-runs root cause/audit by event type, then materializes to Runtime.',
    ingestOne: 'Ingest next signal & evolve',
    kernelStepOne: 'Step once',
    kernelStepDrain: 'Run until queue empty',
    resetSigma: 'Reset σ',
    logicClock: 'Logic clock TS',
    knowledgeCount: 'Knowledge |K|',
    traceSteps: 'Trace steps',
    queueLength: 'Queue |P|',
    gamma: 'Type environment',
    gammaFromCore: 'Synced from Core Load.',
    gammaEmpty: 'None. Load types & predicates in Core Load first.',
    eventQueue: 'Event queue P',
    eventQueueHint: 'Signals from Runtime "Apply" are queued here; click "Step once" to evolve.',
    queueEmpty: 'Queue empty. Generate signals in Runtime and click Apply.',
    knowledgeEvolveTrajectory: 'Knowledge evolution trajectory',
    autoRootCause: 'Auto root cause',
    autoAudit: 'Auto audit',
    materialized: 'Materialized',
    materializedHint: 'Instances or types written to Runtime after each step.',
    knowledgeSetK: 'Knowledge set K',
    noItems: 'No items.',
    traceRecent: 'Trace (recent steps)',
    noTrace: 'No trace.',
    step: 'Step',
    noMoreSignals: 'No more signals. Generate some in Runtime first.',

    graphTitle: 'Knowledge Graph: Γ & σ Evolution',
    graphIntro: 'Dependent type view; drag the slider to change state step and see visible types and terms.',
    graphExampleNote: 'Nodes and edges are example topology (aligned with quality_traceability ontology); future: derive from Core Γ.',
    stateStep: 'State step',
    initialState: 'Γ₀, σ₀ (initial)',
    legendAtom: 'Atom type',
    legendComposite: 'Composite type',
    legendPredicate: 'Predicate',
    legendConstructor: 'Constructor',
    legendTerm: 'Term',

    traceTitle: 'Trace',
    traceIntro: 'T = σ₀ →^⟨e₁,p₁⟩ σ₁ → … ; small-step evolution for causal trace and replay.',
    stepList: 'Step list',
    traceEmpty: 'No trace. Generate signals in Runtime, then "Ingest next signal & evolve" in Kernel.',
    filterByEventType: 'Filter by event type',
    filterAll: 'All',
    clearFocus: 'Clear focus',
    expand: 'Expand',
    collapse: 'Collapse',
    traceFullPage: 'Full trace page',

    scenariosTitle: 'Six Core Scenarios',
    scenariosIntro: 'From all_scenarios_demo: root cause, counterfactual, compliance, audit, governance, AI governance.',
    scenario1Title: '1. Root Cause',
    scenario1Desc: 'prove RootCauseReport: given fail event, auto-construct root cause report.',
    scenario1Run: 'Run root cause',
    scenario2Title: '2. Counterfactual',
    scenario2Desc: 'Factual ctx proves RootCauseReport, counterfactual (no anomalyEx) does not → anomalyEx is necessary.',
    scenario2Run: 'Run counterfactual',
    counterfactualEnvTitle: 'Counterfactual reasoning environment',
    counterfactualEnvIntro: 'Compare the factual world (with anomalyEx) and the counterfactual world (without it); prove RootCauseReport in both. If factual proves and counterfactual does not, the anomaly is causally necessary for root cause.',
    counterfactualGoal: 'Goal: ',
    counterfactualSignals: 'Runtime signal chain',
    counterfactualBuildSignals: 'Build signals in Runtime',
    counterfactualBuildSignalsIntro: 'You can generate signals for both trajectories in Runtime, then evolve in Kernel or run the comparison here.',
    counterfactualBuildFactual: 'Factual: generate proc_step → anomaly → fail_evt (in time order), apply and step in Kernel.',
    counterfactualBuildCounter: 'Counterfactual: generate only proc_step → fail_evt (no anomaly).',
    counterfactualGoRuntime: 'Go to Runtime',
    counterfactualGoScenarios: 'Go to Scenarios',
    counterfactualRunTitle: 'Run comparison',
    scenario3Title: '3. Compliance',
    scenario3Desc: 'enqueue_if_compliant: check signal compliance before ingest.',
    scenario3Run: 'Check compliance',
    complianceEnvTitle: 'Compliance decision environment',
    complianceEnvIntro: 'Check signal compliance before enqueue: only allowed kinds may enqueue; others are rejected with a reason. Use signals generated in Runtime to verify here.',
    complianceEnvRule: 'Current rule',
    complianceValidKinds: 'Compliant kinds: ',
    complianceBuildSignals: 'Build signals in Runtime',
    complianceBuildIntro: 'In Runtime generate proc_step, anomaly, fail_evt (compliant) or sensor, qc_failure (non-compliant), then run the check here or on Scenarios.',
    complianceRunTitle: 'Run compliance check',
    complianceRunIntro: 'Pick a signal kind; the system generates one sample signal and runs the compliance check.',
    complianceCheckWith: 'Check with ',
    complianceSignalJson: 'View signal JSON',
    scenario4Title: '4. Audit',
    scenario4Desc: 'export_audit_trail: export trajectory as audit JSON.',
    scenario4Run: 'Export audit',
    auditEnvTitle: 'Audit & accountability environment',
    auditEnvIntro: 'Export current Kernel trace as audit JSON for traceability and accountability. Build trace in Runtime and Kernel first.',
    auditEnvRule: 'Environment',
    auditRunTitle: 'Export audit',
    auditTraceLength: 'Trace length',
    scenario5Title: '5. Governance',
    scenario5Desc: 'evolve_until_idle: evolve until idle, consume all pending signals.',
    scenario5Run: 'Evolve until idle',
    governanceEnvTitle: 'Governance environment',
    governanceEnvIntro: 'Ingest signals from Runtime simulator into Kernel until idle; demo for complex system governance.',
    governanceEnvRule: 'Environment',
    governanceRunTitle: 'Evolve until idle',
    governanceResultTitle: 'Result',
    governanceConsumed: 'Consumed',
    scenario6Title: '6. AI Governance',
    scenario6Desc: 'verify_ai_suggestion: verify AI suggestion against given type.',
    scenario6Run: 'Verify AI suggestion',
    aiGovernanceEnvTitle: 'AI governance environment',
    aiGovernanceEnvIntro: 'Check whether a term satisfies a type for AI-suggestion compliance.',
    aiGovernanceEnvRule: 'Environment',
    aiGovernanceRunTitle: 'Run type check',
    aiGovernanceResultTitle: 'Result',

    vizRootCauseTitle: 'Root Cause Process',
    vizAnomaly: 'Anomaly',
    vizTimeline: 'Timeline',
    vizCounterfactualTitle: 'Counterfactual Comparison',
    vizFactual: 'Factual World',
    vizCounterfactual: 'Counterfactual World',
    vizNecessary: 'anomalyEx causally necessary',
    vizNotNecessary: 'anomalyEx not causally necessary',
    vizComplianceTitle: 'Compliance Decision Flow',
    vizTypeCheck: 'Type check',
    vizCompliant: 'Compliant',
    vizReject: 'Reject',
    vizAuditTitle: 'Audit Trail',
    vizRawJson: 'Raw JSON',
    downloadAuditJson: 'Download audit JSON',
    vizEvolveTitle: 'Evolve Until Idle',
    vizSignalsQueue: 'Pending signals',
    vizSteps: 'steps',
    vizConsumed: 'consumed',
    vizAiTitle: 'AI Suggestion Verification',
  },
}

const STORAGE_KEY = 'kos-web-locale'
export function getStoredLocale() {
  try {
    const v = localStorage.getItem(STORAGE_KEY)
    if (v === 'zh' || v === 'en') return v
  } catch (_) {}
  return 'zh'
}
export function setStoredLocale(locale) {
  try {
    localStorage.setItem(STORAGE_KEY, locale)
  } catch (_) {}
}
